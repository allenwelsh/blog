##### 所思科技

- 1、说一下浏览器缓存

回答：

- 1、广义缓存分为 http 缓存、Web Worker(离线缓存)、http2 的 push cache
- 2、https 缓存又分为强缓存和协商缓存
- 3、当我们第一次像浏览器请求一个资源的时候，浏览器会返回资源和缓存规则
- 4、http1.0 中是使用 Expires 作缓存标志，但是存在客户端和服务器时间不一致问题
- 5、http1.1 中使用的是 Cache-Control 控制，Cache-Control 是一个组合字段，主要是缓存规则：no-store,no-cache,
  public,private 和 s-maxage 组成，其中 s-maxage 表示该资源要多久后失效
- 6、当再次请求该资源时首先判断资源缓存规则，判断是否过期，如果过期，进入协商缓存，如果没有过期直接使用该资源，如果规则是 no-cache，则直接进入协商缓存
- 7、协商缓存会携带上次带回来 E-Tag 或者 Last-Modify 标志向服务器请求，如果服务器没有更新，则从定向到 304，如果更新，则返回更新后的资源和缓存规则

- 8、缓存导致发版后不更新版本问题：1、静态资源 hash 命名，2、html 不缓存

---

- 2、说一下从浏览器输入 url 到渲染页面过程

回答：

- 1、大概过程：DNS 解析=》建立 TCP 请求（三次握手）=》发送 http 请求（https 需要先交换 ssl 和私钥）=》获取到静态资源=》解析 html=》prefetch css 和 js=》生成 dom 树和 css=》合成 render 树=》计算 layout=》分层和 bitmap=》更新到页面=》关闭 TCP 链接
- 2、补充说明 ssl 证书过程
- 3、补充渲染过程中 ios 和 chrome 差异

---

- 3、说一下最近看的书籍
  回答：

  1、历史的温度；2、朱永胜的 webkit 技术

---

- 4、tcp 过程

回答：

- 1、首先 3 次握手 4 次挥手；
- 2、3 次握手是：C 向 S 发送 SYN 报文，seq 设置为 x，同时进入等待状态；服务器收到 SYN 后，返回 SYN 和 ack，ack 设置为 X+1;seq 设置为 Y,同时进入等待状态;客户端收到后，再次返回 ack（Y+1）和 seq（x+1）,完成握手
- 3、本质是为了证明自己有发送和接收数据的能力
- 4、4 次握手：tcp 是一个全双工的，双方都可以有发送数据的能力，需要各自断开链接，而且都需要 ack 确认

---

- 5、用三个词评价一下自己

- 6、如果一个页面有很 20 个组件组成，每个组件都有自己生命周期和数据请求，如果控制这个数据请求
- 7、说一下同源策略

答：

- 1、所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源；
- 2、不同源存在问题：1、ajax 无法发送请求；2、dom 无法读取；3、cookie、IndexDB、LocalStorage 不可读

---

- 8、说一下 iframe 的跨域问题

回答：

- 1、场景：1、读取子页面或者父页面的变量；2、读取 dom；
- 2、方法：1、document.domain(根域名一致)；2、window.name（不限制同源）;3、postMessage(onmessage 事件)

```js
//父
document.domain = "a.com";
var user = "admin";
//子
document.domain = "a.com";
// 获取父窗口中变量
alert("get js data from parent ---> " + window.parent.user);
```

[如何实现浏览器内多个标签页之间的通信](https://juejin.cn/post/6844904125998563342#heading-64)

- 9、webpack 对相同代码是如何打包成 common 的，策略是什么
- 10、chrome 同一时刻能最多启动多少个 tcp 链接
- 11、如何实现弹幕
- 12、是否做过原生开发
- 13、如何理解前端模块化

##### 海尔

- 1、说一下浏览器 tab 之间通信方式

答：

- 1、websocket：一个服务端，两个页面
- 2、loaclStorage：监听 Storage 事件，限制在同源

---

- 2、说一下最近一直推进的项目是什么，从中学到什么
- 3、说下 vue 的虚拟 dom 理解
- 4、说一下 vue 的 diff 算法
- 5、说一下 promsie 理解，如果让你实现，应该怎么实现
- 6、是否封装过 webpack 插件
- 7、是否写过 webpack 的 loader
- 8、说一下 gzip 算法
- 9、说一下性能优化方案
- 10、是否做过前端项目自动化部署

##### 平安

- 1、说一下对前端架构师对理解
- 2、说一下跨浏览器方案，说一下 Flutter
- 3、浏览器内核的理解
- 4、如何协调团队内部和外部的矛盾
- 5、如何做团队培训

##### NBHR

- 1、如何解决开发过程中 css 重复加载问题和覆盖问题
- 2、如何选择框架，如何评价 react 和 vue
- 3、vue 的双向数据绑定如何实现，会有什么问题，3.0 又是如何实现的
- 4、react 的 hooks 原理是什么
- 5、如果一个应用是复杂数据逻辑，如果选型

##### 微盟

- 1、hooks 细节相关
- 2、react 生命周期的参数

```js
componentDidUpdate(prevProps) {
  // 🔴 This condition will never be true
  if (this.props.fetchData !== prevProps.fetchData) {
    this.props.fetchData();
  }
}

componentWillReceiveProps(nextProps) {
  this.setState({
    likesIncreasing: nextProps.likeCount > this.props.likeCount
  });
}


static getDerivedStateFromProps(nextProps, prevState) {
    const {type} = nextProps;
    // type可能由props驱动，也可能由state驱动，这样判断会导致state驱动的type被回滚
    if (type !== prevState.type) {
        return {
            type,
        };
    }
    // 否则，对于state不进行任何操作
    return null;
}

shouldComponentUpdate(nextProps, nextState) {
    if (this.props.color !== nextProps.color) {
      return true;
    }
    if (this.state.count !== nextState.count) {
      return true;
    }
    return false;
  }

  componentWillUpdate(newProps,newState){
    console.log('trigger:componentDidMount newprops=',newProps,' newState=',newState)
  }
```

- 3、原生和 h5 如何通信

##### 仙豆

- 1、介绍作为 owner 角色需要做的事情
- 2、webpack 有哪些配置
- 3、如何提高 webpack 打包效率
- 4、介绍一下构建前端项目的具体过程
