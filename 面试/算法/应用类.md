#### 单例模式

- 全局缓存、全局状态管理
- 本质就是一个闭包
- vue 中的 Vue 变量

```js
//构造函数
// let instance = null;
function List() {
  if (!List.instance) {
    this.time = new Date().getTime();
    List.instance = this;
  }
  return List.instance;
}
let a = new List();
let b = new List();
console.log(a, b, a === b);

//es5 class模式

class List {
  constructor() {
    if (!List.instance) {
      this.time = new Date().getTime();
      List.instance = this;
    }
    return List.instance;
  }
  show() {
    console.log(111, this.time);
  }
}

let a = new List();
let b = new List();
a.show();
b.show();
console.log(a, b, a === b);
//es6 class模式
```

#### 适配器模式

- 场景
  - 参数适配
  - 方法适配

主要解决兼容性问题，比如对 sdk 对兼容、网络请求数据处理等

```js
class List {
  constructor() {
    this.arr = [];
  }
  push(item) {
    this.arr.push(item);
  }
}

let _hmt = {
  push: (arr) {

    const [eventName, attrName, value] = [...arr.splice(2)];

    let attrObj = {
      [attrName]: value
    };

    sa.track(eventName, attrObj);
  }
}

```

#### 代理模式

- 何谓代理模式，我们常说代理有：代理商、vpn 网络代理

- 动机是啥？

  - 某些情况下基于一些安全、策略的原因不方便直接访问对象，或者说直接访问对象成本较高

- 解决方案

  - 为了解决这个问题，我们可以在访问对象之前增加一个访问层

- 定义

  为了实现某种业务需求，为对象提供一种访问层，以控制对这个对象的访问

- 场景应用
  - ES6 的 Proxy:对对象增加一个代理，这个代理对象可以代理 get、set 等一些对象原型上的方法
  - nginx 代理

```js
let obj = {
  a: 1,
  b: 2,
};

const p = new Proxy(obj, {
  get(target, key, value) {
    if (key === "c") {
      return "我是自定义的一个结果";
    } else {
      return target[key];
    }
  },

  set(target, key, value) {
    if (value === 4) {
      target[key] = "我是自定义的一个结果";
    } else {
      target[key] = value;
    }
  },
});
```

#### 观察者模式

观察者是一种对一个对象对的观察，可以添加观察者，当被观察对象发生变化是可以通知观察者

主要包含：

- 观察对象
- 观察者
- 添加观察者
- 通知观察者

```js
class Obj {
  //观察对象
  constructor() {
    this.listeners = [];
  }
  addListener(listener) {
    this.listeners.push(listener);
  }
  notice() {
    this.listeners.forEach((listener) => {
      console.log(listener); //执行需要处理的事情
    });
  }
}
```

#### 订阅者模式

订阅者模式包含订阅者、发布者、调度中心，
基本逻辑为：调度中心为订阅者订阅事件、同时接收发布者消息，接收消息后按照订阅者的事件
分发事件

vue 就是典型的订阅者模式

```js
class Pubsub {
  //调度中心
  constructor() {
    this.subscribers = {};
  }
  subscribe(event, cb) {
    let cbs = this.subscribers[event];
    if (cbs) {
      cbs.push(cb);
    } else {
      this.subscribers[event] = [cb];
    }
  }
  publish(event, ...args) {
    if (this.subscribers[event]) {
      //该事件有人订阅
      this.subscribers[event].forEach((cb) => {
        cb(args); //执行需要处理的事情
      });
    }
  }
}
```

#### 差别

- 观察者模式：数据源直接通知订阅者发生改变。
- 发布订阅模式：数据源告诉第三方（事件频道）发生了改变，第三方再通知订阅者发生了改变。
- 在设计模式结构上，发布订阅模式继承自观察者模式，是观察者模式的一种实现的变体。
- 在设计模式意图上，两者关注点不同，一个关心数据源，一个关心的是事件消息。

[参考文章](https://www.cnblogs.com/onepixel/p/10806891.html)
