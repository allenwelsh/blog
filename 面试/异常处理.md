# 异常处理

#### js 内置异常类型(7 种)

- 通用错误（Error）
- 语法错误（SyntaxError）语法解析不合理，即语法错误。
- 引用错误（ReferenceError）在读取不存在的变量时抛出，比如没定义变量 a，后面却使用这个变量 a，就会报这种错。
- 类型错误 （TypeError）当一个值的类型错误时抛出该异常，比如传递给函数的参数与预期的不符，就会报这种错误。
- 越界错误 （RangeError）在数字超出合法范围时抛出，比如数组下标越界就会报这种错误
- URI 错误 （URIError）以一种错误的方式使用全局 URI 处理函数而产生的错误
- Eval 函数执行异常（EvalError）

错误类型是可以自定义的

#### 常见的错误

- js 代码语法异常、对象属性异常获取、兼容性问题
- api 数据请求错误（5xx、4xx）
- 静态资源加载失败
- promise 异常
- 跨域错误

#### 异常处理

##### try-catch

- 使用场景：对于可以预测到的错误进行处理
- 缺点： 1、无法捕获异步错误；2、无法捕获语法错误;
- 捕获范围：1、Error

```js
///Error对象类容
console.log("name:", err.name);
console.log("message:", err.message);
console.log("stack:", err.stack);

name: Error
message: Error while executing the code
stack: Error: Error while executing the code
    at <anonymous>:1:13
```

##### window.onerror

- 使用场景：对于不可预测到的错误进行处理
- 缺点： 1、无法捕获静态资源错误及网络请求；2、不能捕获语法错误
- 捕获范围：在 try-catch 的基础上，它可以捕获异步错误（定时器）

window.onerror()函数主要用来捕获意料之外的错误

```js
/**
 * @param {String}  message    错误信息
 * @param {String}  source     出错文件
 * @param {Number}  lineno     行号
 * @param {Number}  colno      列号
 * @param {Object}  error      Error对象（对象）
 */
window.onerror = function (message, source, lineno, colno, error) {
  console.log("捕获到异常：", { message, source, lineno, colno, error });
};
```

##### window.addEventListener

> window.onerror 函数不能捕获静态资源加载失败的异常情况，当资源（图片或脚本）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的 onerror()处理函数，这些 error 事件不会向上冒泡到 window 上，但是可以被 window.addEventListener 捕获。

- 使用场景：异步网络请求（src 脚本、图片等）
- 缺点：不同浏览器 error 不一样

* 资源

```js
window.addEventListener('error', function(event) { ... })

当资源（如img或script）加载失败，加载资源的元素会触发一个Event接口的error事件，并执行该元素上的onerror()处理函数。这些error事件不会向上冒泡到window，但可以在捕获阶段被捕获
因此如果要全局监听资源加载错误，需要在捕获阶段捕获事件
//图片加载失败使用默认图片，依旧加载失败超过三次使用base64图片
window.addEventListener('error',function(e){
    let target = e.target, // 当前dom节点
        tagName = target.tagName,
        count = Number(target.dataset.count ) || 0, // 以失败的次数，默认为0
        max= 3; // 总失败次数，此时设定为3
    // 当前异常是由图片加载异常引起的
    if( tagName.toUpperCase() === 'IMG' ){
        if(count >= max){
            target.src = 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD//AK3/ALYH+5hX6FV5N4Y/5GHwx/vyf+iJa9ZrysPhoYVShDZu/potDmwWFhhIzhT2bv6aLQ//Z';
        }else{
            target.dataset.count = count + 1;
            target.src = '//xxx/default.jpg';
        }
    }
},true)//为捕获模式
```

##### promise 异常

- Promise 中的异常不能被 try-catch 和 window.onerror 捕获，这时候我们就需要监听 unhandledrejection 来帮我们捕获这部分错误。

promise 本身也包含 catch 错误处理，对于没有处理的 promise 异常，可以使用：

```js
window.addEventListener("unhandledrejection", function (e) {
  e.preventDefault();
  console.log("捕获到 promise 错误了");
  console.log("错误的原因是", e.reason);
  console.log("Promise 对象是", e.promise);
  return true;
});
```

##### vue

```js
Vue.config.errorHandler = (err, vm, info) => {
  console.error("通过vue errorHandler捕获的错误");
  console.error(err);
  console.error(vm);
  console.error(info);
};
```

##### react

React 16 提供了一个内置函数 componentDidCatch，使用它可以非常简单的获取到 react 下的错误信息

```jsx
//组件内
componentDidCatch(error, info) {
    console.log(error, info);
}
```

为了方便使用 UI 的某部分引起的 JS 错误不应该破坏整个程序，为了帮 React 的使用者解决这个问题，React 16 介绍了一种关于错误边界（error boundary)的新观念。

```jsx
<ErrorBoundary>
  <MyWidget />
</ErrorBoundary>
```

##### 崩溃和卡顿

##### axiox

[参考文章](https://blog.fundebug.com/2018/12/07/how-to-handle-frontend-error/)
